\chapter{Desarrollo de la aplicación.}

\section{Desarrollo Web.}

A continuación se describe detalladamente el proceso de construcción que se utilizó para el desarrollo de la aplicación web, seguiendo el estándar de \emph{Rails}, se adoptó una metodología ágil\footnote{Es un proceso de desarrollo de software, desarrollado inicialmente por James Martin en 1980. El método comprende el desarrollo iterativo, y la construcción de prototipos, tiende a englobar también la usabilidad, utilidad y la rapidez de ejecución.} buscando velocidad en el desarrollo del producto, así como calidad, pues la aplicación supliría las necesidades de los usuarios y se entregaría en un tiempo acorde según los límites de tiempo del proyecto.

\subsection{Especificaciones.}

El primer paso para desarrollar apropiadamente una aplicación guiada por tests(\emph{Test Driven Development - TDD}), es definir las especificaciones que determinan el comportamiento del sistema, dichas especificaciones más tarde se convertirán en la base de los tests para el desarrollo de la aplicación.\\

En este punto, se describió la aplicación Web a ser escrita teniendo en cuenta la definición del problema y el marco referencial, la tarea principal entonces sería integrar datos con contenidos para lograr el desarrollo final de la aplicación, después de tener claro la necesidad a cubrir y de que se necesitaba brindar un ambiente de fácil acceso y manipulación para los usuarios, se decidió desarrollar una aplicación web con las siguientes especificaciones(especificaciones que mas tarde se ampliarían para la construcción de los test.):


\begin{itemize}
\item[$\bullet$] Sistema de usuarios protegido por contraseña.
\item[$\bullet$] Cada usuario puede registrar un portafolio.
\item[$\bullet$] Cada portafolio esta compuesto por títulos.
\item[$\bullet$] Los títulos representan el estado personal de una acción registrada por el usuario, para de esa manera determinar, si la inversión le representa a su propietario una perdida o una ganancia.
\item[$\bullet$] Dentro del portafolio se pueden agregar, actualizar, comparar y eliminar títulos.
\item[$\bullet$] Cada título puede ser seleccionado para inspeccionar su comportamiento durante un rango de tiempo determinado por el usuario.
\item[$\bullet$] Los títulos de cada usuario pueden ser comparados simultáneamente con el apoyo de los contenidos 3D.
\item[$\bullet$] Los títulos se basan en la información que se obtiene al actualizar las acciones.
\item[$\bullet$] Las acciones se actualizan cada veinte minutos cuándo el mercado esta abierto.
\item[$\bullet$] La página principal no necesita registro, evidencia el comportamiento del mercado con una gráfica en 3D y muestra el estado actual de cada acción.
\end{itemize}

\subsection{Definición de modelos.}

Con el comportamiento de la aplicación claro, era necesario entonces definir los datos con los que la misma trabajaría, que tablas se necesitarían, que campos, y que tipos de datos estarían siendo manipulados por la aplicación, y cuáles  alimentarían los contenidos 3D.\\

Aparte de los definición de los modelos involucrados, se buscaba estar en la capacidad de trabajar bajo un patrón \textbf{ActiveRecord}\footnote{Es un enfoque al problema de acceder a los datos de una base de datos. Una fila en la tabla de la base de datos se envuelve en una clase, de manera que se asocian filas únicas de la base de datos con objetos del lenguaje de programación usado. Cuando se crea uno de estos objetos, se añade una fila a la tabla de la base de datos. Cuando se modifican los atributos del objeto, se actualiza la fila de la base de datos. La clase envoltorio implementa métodos de acceso para cada columna de la tabla o vista.} pensando en un enfoque \textbf{ORM}\footnote{Léase \textbf{ORM} en el glosario.} que permitiera manipular los registros de la base datos como si se trataran de objetos definidos en el lenguaje de programación \emph{Ruby}.\\

El modelo entidad relación final, y que representa la estructura de la base de datos de la aplicación es el que se muestra en la Figura \ref{fig:erd}, según la información recogida de las especificaciones, era claro que se necesitaba un modelo que representara los usuarios, a su vez dichos usuarios tienen relacionado un portafolio(relación \emph{1..1}), cada portafolio actúa como contenedor de títulos(relación \emph{1..n}), indirectamente entonces, el usuario posee títulos, como sucede en la vida real, el modelo \emph{stock\_action} representa la acción real en el mercado, y sobre la cual existen múltiples títulos asociados.

\begin{figure}[h]
	\centering
		\includegraphics[scale=0.5]{erb_mertd.jpg}
		\caption{Modelo Entidad Relación - Mertd(Mercado 3D)}
	\label{fig:erd}
\end{figure}

Finalmente el modelo \emph{record} es sobre el cual se registran todos los movimientos de las acciones, es decir, sobre el que se hacen las actualizaciones según el estado de una acción, por ejemplo, cada vez que se obtiene información nueva indicando el estado de una acción, un registro nuevo es agregado y guardado en este modelo, luego este registro es usado por otros modelos para calcular el estado de una inversión de forma personalizada.\\

La siguiente porción de código de la aplicación, muestra claramente cómo se puede sacar provecho al utilizar un patrón como \textbf{ActiveRecord}, según este patrón, si existe una tabla \emph{titles} debe haber una clase \emph{Title} asociada, sobre la cual se hace el mapeo.

\begin{verbatim}
	t = Title.new
	t.initial_price = 15250.66
	t.quantity = 10000
	t.portafolio = p #p es un portafolio existente cuya id es 1
	t.stock_action = s_a #s_a es una acción existente cuya id es 15
	t.save
	#otra manera mas corta de hacer este regristro, podría ser:
	#t = Title.new(:initial_price => 15250.66, :quantity => 10000, 
	#			   :portafolio => p, :stock_action => s_a)
	#
\end{verbatim}

A nivel de bases de datos, las anteriores declaraciones son interpretadas de la siguiente manera:

\begin{verbatim}
INSERT INTO titles 
  (initial_price, quantity, portafolio_id, stock_action_id) 
  VALUES (15250.66, 10000, 1, 15);
\end{verbatim}

Cabe resaltar que siempre será más rápido ejecutar directamente el código nativo interpretado por el motor de base de datos, pero en éste caso se opto por la claridad de código y la manipulación de objetos pues no se requirió diseñar consultas que hicieran que la diferencia de tiempos entre uno y otro método fuera considerable.

\subsection{Configuración.}

Al tratarse de una aplicación web, la configuración estuvo enfocada en la determinación de que servidores web utilizar, y que motor de bases de datos, así como la integración de estos con la aplicación.

\subsubsection{Servidor Web - \emph{Clusters}}

En el lado de los servidores, se eligió \textbf{Mongrel}\footnote{Es una libreria HTTP y un servidor web para aplicaciones escritas en \emph{Ruby}. Una característica de \emph{Mongrel} es que usa HTTP plano, en vez de \emph{FastCGI} ó \emph{SCGI}, para comunicarse con otros servidores que podrían estar una capa encima de éste.}, encargado de correr la aplicación web a modo de \emph{clusters},\footnote{Los \emph{Mongrel Clusters} son un conjunto de procesos de \emph{Mongrel} con una configuración común que pueden ser manejados por un servidor \emph{Proxy}} éstos interpretan directamente el código escrito en \emph{Ruby} y responden a peticiones HTPP, cuándo se utiliza este esquema se necesita incluir un \textbf{Proxy Sever}\footnote{Es un servidor que intercepta las conexiones de red que un cliente hace a un servidor de destino para actuar como enrutador.} en la primera capa del servidor web, encargado de enrutar las peticiones HTTP a un determinado \emph{cluster} dependiendo del estado de los mismos, para el desarrollo de la aplicación se eligió \textbf{Nginx}\footnote{http://nginx.net/} como servidor proxy.\\

Los siguientes archivos, representan la configuración actual de la aplicación, tanto para \emph{Mongrel} asi como para \emph{Nginx}\\

Archivo de configuración para los \emph{clusters}, el número de \emph{clusters} esta determinado por el valor de la variable \emph{servers}, el primer \emph{cluster} corre en el puerto especificado en la variable \emph{port}, los puertos de los n-1 restantes \emph{clusters} son determinados incrementando en 1 el valor del puerto del último \emph{cluster} al que se le haya asignado un puerto, en este caso, el primer \emph{cluster} corre en el puerto 8000, y el segundo en el puerto 8001.

\begin{verbatim}
  port: "8000" 
  cwd: /home/mertd/www/mertd/current/
  log_file: log/mongrel.log 
  environment: production 
  address: 127.0.0.1 
  pid_file: log/mongrel.pid 
  servers: 2
  docroot: public 
  user: mertd
  group: mertd 
\end{verbatim}

Archivo de configuración de \emph{Nginx}

\begin{verbatim}
	upstream mertd {
		/* Cada uno de los mongrel clusters, en este caso dos */
		/* Corriendo en los puertos 8000 y 8001 respectivamente */
		server 127.0.0.1:8000; 
		server 127.0.0.1:8001;
	}

	server {
	    listen 80;
	    server_name 127.0.0.1;
	    client_max_body_size 25M;

	    root /home/mertd/www/mertd/current/public/;
	    access_log  /home/mertd/www/mertd/current/log/access.log  main;

	    if (-f $document_root/system/maintenance.html) {
	      rewrite  ^(.*)$  /system/maintenance.html last;
	      break;
	    }

	    location / {
	      proxy_set_header  X-Real-IP  $remote_addr;
	      proxy_set_header  X-Forwarded-For $proxy_add_x_forwarded_for;
	      proxy_set_header Host $http_host;
	      proxy_redirect false;
	      proxy_max_temp_file_size 0;
	      if (-f $request_filename) {
	        break;
	      }
	      if (-f $request_filename/index.html) {
	        rewrite (.*) $1/index.html break;
	      }
	      if (!-f $request_filename) {
	        proxy_pass http://mertd;
	        break;
	      }
	    }

	    error_page   500 502 503 504  /500.html;
	    location = /500.html {
	    root /home/mertd/www/mertd/current/public;
	    }
	 }
\end{verbatim}

\subsubsection{Base de datos}

La integración de la aplicación con la base de datos, es uno de los aspectos en los que \emph{Rails} saca ventaja de su filosofía CoC (\emph{Convention over Configuration}), en este punto sólo es necesario definir que motor de base de datos soportado por \emph{Rails} se utilizará y en 7 líneas de código la integración se define.

\begin{verbatim}
development: 
  adapter: mysql 
  encoding: utf8 
  database: mertd_development 
  username: root 
  password: 
  host: localhost	
\end{verbatim}

\emph{Rails} cuenta con tres tipos de ambientes que se tocarán más a fondo en la siguiente sección, las líneas anteriores corresponden a la configuración de la base de datos para el ambiente de \emph{desarrollo}, a partir de ese momento, la base de datos puede ser creada, modificada, o eliminada sin necesidad de utilizar directamente código SQL, la base de datos de \emph{Mertd} fue creada siguiendo un patrón de migraciones\cite{ror:cookbook}\footnote{La base de datos es modificada como si se tratase de una máquina de estados, cada migración agrega, modifica, elimina o actualiza la estructura de la base de datos} para facilitar escabilidad entre base de datos y aplicación.\\

A modo de ejemplo, las siguientes sentencias recrean la creación de la base de datos, y el primer modelo de la aplicación siguiendo el patrón de migraciones.\\

La siguiente tarea crea la base de datos basado en el archivo de configuración.

\begin{verbatim}
  rake db:create 
\end{verbatim}

Como se mencionó anteriormente, la base de datos se modifica basado en migraciones, las siguiente sentencia, muestra como crear y detallar el comportamiento de una migración, en este caso para crear la tabla/modelo usuarios. 

\begin{verbatim}
  script/generate migration create_users
\end{verbatim}

El script anterior genera un archivo en el que se definen las operaciones que se aplicaran a la base de datos cuando la migración sea ejecutada, la siguiente porción de código muestra el contenido de dicho archivo utilizado en \emph{Mertd}

\begin{verbatim}
class CreateUsers < ActiveRecord::Migration
  def self.up
    create_table "users", :force => true do |t|
      t.column :login,                     :string, :limit => 40
      t.column :name,                      :string, :limit => 100
      t.column :email,                     :string, :limit => 100
      t.column :crypted_password,          :string, :limit => 40
      t.column :salt,                      :string, :limit => 40
      t.column :created_at,                :datetime
      t.column :updated_at,                :datetime
      t.column :remember_token,            :string, :limit => 40
      t.column :remember_token_expires_at, :datetime


    end
    add_index :users, :login, :unique => true
  end

  def self.down
    drop_table "users"
  end
end
\end{verbatim}

Para cada migración se debe definir una tarea dependiendo si se realiza la migración o si por el contrario se esta revirtiendo una migración, la migración anterior por ejemplo, para ser revertida utiliza la sentencia \emph{drop\_table}.\\

Finalmente para actualizar la base de datos se corre la migración mediante una tarea \emph{rake}\footnote{Un programa de construcción de \emph{Ruby} con características similares a \emph{make}}.

\begin{verbatim}
  rake db:migrate  #crea la tabla usuarios ("users")
  rake db:rollback #elimina la tabla usuarios ("users")
\end{verbatim}

\subsection{Ambientes.}
\subsection{Daemon - \emph{Stock Getter}.}
\subsection{\emph{TDD Cycle}}

\section{Desarrollo Contenidos 3D}
La arquitectura dentro de una escena en Unity3D consiste en un conjunto de GameObjects que interactúan entre si para mostrar un evento/animación en una escena; Dichos objetos interactúan entre si, basándose en una jerarquía de objetos, donde la traslación/rotación/escalamiento de un padre afecta directamente a los hijos.

ACA MOSTRAR LA INTERFAZ DE UNITY CON LOS PADRES / HIJOS

Se decidió entonces dividir el programa en 3 grandes modulos.
ACA VA IMAGEN GRILLA DE LOS MODUlOS
\subsection{Módulo de detección de datos de información del exterior:}

\subsection{Módulo de renderizado de escena(Grapher):}

\subsection{Modulo de información de Objetos:}



Basicamente 4 tipos de gráficos fueron los que se decidieron desarrollar y fueron: Barras, Espiral, Superficie y el `Campo'. cada gráfica ofrece información relevante para cada tipo de variable que se esta analizando. 

Barras: Son las típicas barras que se pueden encontrar en cualquier visualizacion de acciones, pero con el valor agregado de que permiten ver el comportamiento de una o varias acciones a través del tiempo.

Espiral: Este tipo de gráfica permite comparar rendimientos de varias acciones por medio del porcentaje de variación de cada una en un momento determinado, es el único tipo de grafico que no permite comparar acciones a través del tiempo, pues lo único que interesa en este gráfico, es determinar de una manera fácil y rápida que acciones estan generando mas rentabilidad, cuales estan perdiendo y cuales estan invariantes en un tiempo determinado.

Superficie: Este tipo de gráfico también compara rentabilidades de dos o mas acciones a través del tiempo con respecto a la mayor/menor  rentabilidad de todas las acciones en un momento determinado  y va generando una superficie 3D que describe el comportamiento de la bolsa a travez de un periodo de tiempo.

Campo: Es el tipo de gráfico mas complejo que se realizó, pues en este gráfico comparamos variables de cantidad Vs Rentabilidad a travez del tiempo, entonces a través de estas variables podemos inferir si una accion se esta tranzando en la bolsa en mucha cantidad o no y si dicha acción esta siendo rentable; Este grafico provee una serie de "Zonas" que ayudan al usuario a determinar las acciones en que estado se encuentran en un momento determinado, y asi inferir facilmente si la acción esta generando perdidas o ganancias.

 

\section{Desarrollo protocolo de comunicación.}

\section{Deployment}

\section{SCM}